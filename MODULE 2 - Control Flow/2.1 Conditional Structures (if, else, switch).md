# Module 2.1 – Conditional Structures (if, else, switch)

## Introduction

Conditional structures control program execution by enabling decision-making based on evaluated conditions. They introduce branching logic, allowing a program to follow different execution paths depending on runtime data. In Java, the primary conditional constructs are `if`, `if-else`, `else if`, and `switch`. Each serves a specific role in structuring control flow clearly and predictably.

---

## The `if` Statement

The `if` statement executes a block of code only when its condition evaluates to `true`. If the condition is `false`, the block is skipped and execution continues with the next statement.

### Syntax

```java
if (condition) {
    // code executed if condition is true
}
```

### Example

```java
int age = 18;

if (age >= 18) {
    System.out.println("You are an adult.");
}
```

This structure is appropriate when only one conditional branch is required.

---

## The `if-else` Statement

The `if-else` structure defines two mutually exclusive execution paths. One block executes if the condition evaluates to `true`; the alternative block executes if it evaluates to `false`.

### Syntax

```java
if (condition) {
    // executed if true
} else {
    // executed if false
}
```

### Example

```java
int age = 16;

if (age >= 18) {
    System.out.println("You are an adult.");
} else {
    System.out.println("You are a minor.");
}
```

Only one block is executed during runtime.

---

## The `else if` Structure

The `else if` structure allows sequential evaluation of multiple conditions. Conditions are evaluated in order from top to bottom. Execution stops at the first condition that evaluates to `true`, and its corresponding block is executed. If no condition is satisfied, the optional `else` block executes.

### Syntax

```java
if (condition1) {
    // block 1
} else if (condition2) {
    // block 2
} else {
    // default block
}
```

### Example

```java
int grade = 85;

if (grade >= 90) {
    System.out.println("Excellent");
} else if (grade >= 70) {
    System.out.println("Good");
} else if (grade >= 50) {
    System.out.println("Average");
} else {
    System.out.println("Fail");
}
```

The ordering of conditions is critical. More restrictive conditions must precede broader ones to avoid unreachable code.

---

## The `switch` Statement

The `switch` statement compares a single variable against multiple constant values. It provides a structured alternative to multiple `else if` statements when evaluating discrete, fixed values.

### Syntax

```java
switch (variable) {
    case value1:
        // code
        break;
    case value2:
        // code
        break;
    default:
        // code if no case matches
}
```

### Example

```java
int day = 3;

switch (day) {
    case 1:
        System.out.println("Monday");
        break;
    case 2:
        System.out.println("Tuesday");
        break;
    case 3:
        System.out.println("Wednesday");
        break;
    default:
        System.out.println("Invalid day");
}
```

The `default` block executes when none of the specified cases match the variable’s value.

---

## The `break` Statement and Fall-Through

Within a `switch`, the `break` statement terminates execution of the current case. If `break` is omitted, execution continues into the subsequent case blocks regardless of their labels. This behavior is known as fall-through.

### Example Without `break`

```java
int number = 1;

switch (number) {
    case 1:
        System.out.println("One");
    case 2:
        System.out.println("Two");
}
```

### Output

```
One
Two
```

In most situations, `break` should be included to ensure predictable control flow. Fall-through should only be used deliberately.

---

## Conceptual Summary

Conditional structures are fundamental to control flow in software systems. They allow programs to diverge from purely sequential execution and respond dynamically to varying inputs and states. Proper use of `if`, `if-else`, `else if`, and `switch` enhances readability, logical correctness, and maintainability. Mastery of these constructs is essential for implementing validation logic, state transitions, rule-based systems, and user interaction flows.